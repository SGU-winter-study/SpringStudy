# 실전! 스프링 부트와 JPA 활용1 -  2일차(도메인 분석 설계)

### 요구사항 분석 및 도메인 모델과 테이블 설계

요구사항에서 주어진 회원 기능, 상품 기능, 주문 기능, 기타 요구사항을 화면과 설계에 앞으로 녹일 것이다. 

요구사항에 따라 도메인 모델과 테이블 설계를 해야한다. 엔티티의 속성과 연관관계를 주어진 요구사항에 따라 표시한다. 일대다 관계, 일대일 관계, 다대일 관계, 다대다 관계, 상속 구조, 양방향, 단방향 관계 등이 있다. 

#### 연관관계 매핑 분석

객체에서는 다대다 관계 가능하지만 관계형 데이터베이스에서는 다대다 관계 일반적인 설계에서 쓰지 않는다. 다대다 관계를 일대다, 다대일 관계로 풀어내기 위해 사이에 매핑 테이블을 넣는다.

원칙 : 외래키가 있는 곳을 연관관계의 주인으로 정해라. 일대다 관계에서는 항상 다쪽에 외래키가 있으므로 다쪽을 연관관계 주인으로 정하면 된다.

회원과 주문 : 일대다, 다대일의 양방향 관계다. 따라서 연관관계의 주인을 정해야 한다. 외래키가 있는 주문을 연관관계의 주인으로 정하는게 좋다. 주인쪽에 값을 바꿔야 값이 바뀌고 거울 쪽은 단순히 값을 조회만.

주문상품과 주문 : 다대일 양방향 관계이다. 외래키가 주문 상품에 있으므로 주문상품이 연관관계 주인.

주문상품과 상품 : 다대일 단방향 관계. 주문상품이 연관관계 주인

주문과 배송 : 일대일 양방향 관계. 주문이 연관관계 주인

### 엔티티 클래스 개발

실무에서 Getter는 열어두고 Setter는 꼭 필요한 경우에만 사용하는 것을 추천한다.

```java
@Column(name = "member_id")
private Long id;
```

객체는 타입이 분명하지만 테이블은 타입이 따로 없으므로 엔티티의 식별자는 id 를 사용하고 PK 컬럼명은 member_id 를 사용했다.

```java
@OneToMany(mappedBy = "member")
```

누가 외래 키값을 업데이트 하게 할 거지?! 둘다 바꾸면 혼란스러워. 연관관계 주인 정하자. 외래 키와 가까운 곳으로. 

order 테이블에 있는 member 필드에 의해 매핑이 된거야라는 의미. 내가 매핑을 하는게 아니라 매핑된 거울일 뿐이야. 값을 넣는다고 해서 외래키 값이 변하지 않는다.

```java
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "dtype") // 추상클래스에
@DiscriminatorValue("B") // 구현 클래스에
```

상속관계 매핑을 하기 위한 전략으로 이 예제에서는 한 테이블에 다 넣는 싱글 테이블 전략을 선택한다. 추상 클래스 위에 어노테이션으로 전략을 표시해준다. 또한 싱글 테이블에서 구현체를 어떤 것을 기준으로 구분할지도 명시해준다.

일대일 관계에서는 외래키를 양쪽에 둘다 둬도 되지만 보통 엑세스를 많이 하는 쪽에 둔다. 여기서는 주문을 바탕으로 접근할 일이 많으니까 주문에 외래키를 둔다. 그러면 연관관계 주인도 주문으로.

@ManyToMany 는 편리한 것 같지만, 중간 테이블( CATEGORY_ITEM )에 컬럼을 추가할 수 없고, 세밀하게 쿼리를 실행하기 어렵기 때문에 실무에서 사용하기에는 한계가 있다

연관관계 편의 메서드 : 양방향 관계에서 비즈니스 로직에 양쪽 값을 넣어주는 로직을 각각 넣어주는게 아니라 메서드 하나를 통해 양쪽에 값을 다 넣어주는 메서드이다. 핵심적으로 컨트롤하는 쪽에 배치하는 것이 좋음.

### 엔티티 설계시 주의점

- 엔티티에는 가급적 Setter를 사용하지 말자. 

  Setter가 모두 열려 있으면 변경 포인트가 너무 많아서 유지 보수가 어렵다.

- **모든 연관관계는 지연로딩으로 설정!**

  즉시로딩(EAGER)은 예측이 어렵고 어떤 SQL이 실행될지 예측하기 어렵다. 모든 연관관계를 지연로딩(LAZY)으로 설정하자! 연관된 엔티티를 조회해야하면 fetch join으로 가져오면 된다. @ ManyToOne, @OneToOne은 기본 fetch 전략이 EAGER이라 LAZY로 따로 설정해줘야 한다.

  ````java
  @ManyToOne(fetch = FetchType.LAZY)
  @OneToOne(fetch = FetchType.LAZY)
  ````

- 컬렉션은 필드에서 초기화 하자

```java
 @OneToMany(mappedBy = "member")
 private List<Order> orders = new ArrayList<>();
```

​		null 문제에서 안전하고 코드도 간결하다

- 테이블, 컬럼명 생성 전략

  스프링 부트 신규 설정 (엔티티(필드) 테이블(컬럼))

  1. 카멜 케이스 -> 언더스코어(memberPoint member_point)
  2. .(점) ->  _(언더스코어)
  3. 대문자 -> 소문자
