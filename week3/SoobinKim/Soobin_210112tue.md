## URI와 HTTP 메소드
URI는 리소스(ex. 회원)단위의 계층 구조로 설계할 것 (복수 단어 사용 권장)
그러나 리소스만을 이용하여 URI 생성이 힘든 경우에는 예외적으로 처리 방식 등을 명명하여 URI에 포함시키는 **컨트롤 URI**를 사용하기도 한다.

x를 y해라 => x는 리소스, y는 메소드
리소스는 URI로 구분, 메소드는 HTTP 메소드를 통해 구분

HTTP 메소드 = 클라이언트가 서버에 기대하는 바
* GET
리소스 조회
* POST
요청 데이터 처리(데이터를 무조건 담아서 보내야 함), 주로 등록
* PUT
리소스 대체(덮어쓰기), 없으면 생성
* PATCH
리소스 부분 변경
* DELETE
리소스 삭제
(정확히 말하면 리소스가 아니라 Representation이다.)

#### GET
리소스를 조회한다. 어떤 리소스를 조회할지는 HTTP 메세지의 query를 통해서 전달한다. 서버는 이에 상응하는 데이터를 응답 데이터로 클라이언트에 다시 보내준다(주로 JSON 형식).

#### POST
요청한 데이터에 대한 처리를 수행한다. 즉 클라이언트가 처음부터 서버에 데이터를 전송한다. 그리고 서버는 message body를 통해 들어온 데이터를 처리한다. 새로운 리소스로 등록하기도 하고, 해당 데이터를 이용해서 프로세스를 처리하기도 한다. 프로세스를 처리한다는 것은 단순히 데이터를 생성하거나 변경하는 것을 넘어서, "프로세스의 상태 변화(->서버 단에서 큰 변화가 발생)를 처리"하기도 한다는 것이다. (그렇기 때문에 POST의 결과로 항상 새로운 데이터가 생성되는 것은 아니다.)
또한 입력받은 데이터를 통해 리소스를 조회할 목적으로 조회 데이터를 메세지 바디에 넣어 서버에 함께 보내고 싶은데 GET을 지원하지 않는 서버인 경우 POST를 사용하기도 한다. (처리하기 애매한 경우 전부 POST를 사용한다고 봐도 무방하다.)


#### PUT
"붙여넣기"의 기능과 유사하다. 리소스가 존재하는 경우 덮어쓰기를 해서 완전히 대체하고(기존에 존재하는 리소스를 아예 삭제해버리고 다시 올리고), 없는 경우 새로 생성한다. POST와의 차이는, 클라이언트가 처음부터 리소스의 정확한 위치를 알고(식별하고) 지정한다는 것이다. "완전히 대체한다"는 점 때문에 수정 기능으로 사용하지는 않는다.


#### PATCH
수정에 주로 사용한다. PUT과 달리, 리소스를 완전히 대체하는 것이 아니라 일부분만 대체하는 것이 가능하다. (PATCH가 간혹 지원이 되지 않는 서버의 경우 POST를 사용하면 된다.)


#### DELETE
리소스를 삭제한다.



## HTTP 메소드의 속성
* 안전(Safe)
호출해도 리소스를 변경하지 않는다. GET의 경우 '조회'만을 하므로 안전하다. 그 외 POST, PUT 등은 안전하지 않다.

* 멱등(Idempotent)
한 번을 호출하든 n번을 호출하든 결과가 동일하다. f(f(x)) = f(x).
결과가 동일하면 되기 때문에 "최종 결과"가 비교 대상이다. 또한 동일한 요청만을 반복적으로 호출했을 때를 비교하기 때문에 외부 요인으로 인해 리소스가 변경되는 상황은 고려하지 않는다. 그렇기 때문에 GET을 포함하여 PUT, DELETE도 멱등하다. 단, POST의 경우 멱등이 아니다. 여러 번 호출되면 결과가 바뀌기 때문이다. (결제를 2번 하면 안 됨.)
멱등 속성의 존재 이유는, 서버가 정상적인 응답을 반환하지 못했을 때 클라이언트가 동일한 요청을 다시 해도 되는지를 판단하기 위함이다.

* 캐시가능
응답 결과를 캐싱하여 사용하는 것이 가능하다. GET, HEAD, POST, PATCH가 캐시 가능하지만, 실제로 캐시로 사용하는 것은 GET, HEAD 정도이다. (POST, PATCH는 본문 내용을 캐시 키로 고려하는 것이 쉽지 않기 때문.



## HTTP 메서드 활용
클라이언트에서 서버로 데이터를 전달하는 방식은 크게 두 가지이다:
1. 쿼리 파라미터를 통해 URI에 담아 전달
GET 방식, 주로 검색과 같은 정렬 필터에 사용
2. 메시지 바디를 통한 데이터 전송
POST, PUT, PATCH 방식, 리소스의 변경이 일어날 때(ex. 새로운 회원 정보 등록) 사용한다.

클라이언트에서 서버로 요청을 보내는 (데이터를 전송하는 경우 포함) 것은 다음과 같은 상황이 있다.
#### 정적 데이터 조회
이미지나 텍스트와 같이 정적 데이터를 조회할 때는 일반적으로 GET 방식을 사용하고, 리소스 경로만으로 조회가 가능하기 때문에 쿼리 파라미터 또는 추가적인 데이터를 전송할 필요가 없다.

#### 동적 데이터 조회
게시판과 같이 데이터의 변동이 발생하는 곳에서의 조회로, 마찬가지로 조회이기 때문에 GET 방식을 사용한다. 쿼리 파라미터를 통해서 데이터를 정렬 필터하기 때문에 쿼리 파라미터를 사용해서 서버로 필터(검색어) 데이터를 전달한다.

#### HTML Form 데이터 전송
사용자로부터 입력받은 정보를 서버에 전달하는 것으로, 리소스의 변경이 발생하기 때문에 POST 방식을 사용한다. (지원 자체는 GET, POST 둘 다 한다.) Content Type은 크게 다음과 같다.
- application/x-www-form-urlencoded
: form의 내용을 메시지 바디를 통해 key-value 형태로 전달한다. 이 때 전송되는 데이터는 url encoding 처리된다.
- multipart/form-data
: 파일 업로드와 같은 binary data를 전송할 때 사용된다. 여러 개의 파일과 폼의 내용을 함께 전송하는 것이 가능하다.

#### HTTP API 데이터 전송
서버에서 서버로 백엔드 통신을 할 때 (HTML이 없을 때), 앱이나 웹 클라이언트 환경(HTML Form 전송 대신 JS를 통한 통신 환경 -> AJAX)에서 서버로 통신할 때 주로 사용한다. 즉 HTMLL Form을 받지 않는 데이터 통신 상황에 사용한다. POST, PUT, PATCH는 메시지 바디를 통해 데이터를 전송하고, GET은 쿼리 파라미터를 이용해 데이터를 전송한다. 표준 Content Type으로 application/json을 사용한다.
* 컬렉션(Collection) => 많이 사용
: POST 기반의 등록 방식에서 서버가 관리하는 리소스 디렉토리. PUT과 달리 POST는 클라이언트는 등록될 리소스의 URI를 모르고, 서버에서 URI를 생성한다. 이렇게 서버가 생성하고 관리하는 리소소의 디렉토리(ex. /members)를 컬렉션이라고 한다.
* 스토어(Store)
: PUT 기반의 등록 방식에서 클라이언트가 관리하는 리소스 저장소. 클라이언트가 리소스 URI를 알고 있는 경우(ex. 파일을 업로드할 때, 파일명은 클라이언트가 알고 있다.)에 클라이언트가 리소스의 URI를 지정하여 관리한다.
* HTML Form 사용
: HTML Form은 GET, POST만을 지원한다. (DELETE, PUT, PATCH 등 사용 불가.) 그렇기 때문에 회원 삭제, 회원 수정과 같은 기능을 전부 POST로 구현해야 한다. (w/ Control URI, Controller) 이렇게 HTTP 메소드로 해결이 어려운 경우에 사용한다.


