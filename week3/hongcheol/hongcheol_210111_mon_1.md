# 웹 스코프

웹 스코프의 특징
웹 스코프는 웹 환경에서만 동작한다. 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다. 
웹 스코프 종류는 다음과 같다.
request: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.
session: HTTP Session과 동일한 생명주기를 가지는 스코프
application: 서블릿 컨텍스트( ServletContext )와 동일한 생명주기를 가지는 스코프 
websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프


웹 라이브러리를 추가하면 스프링 컨테이너는 AnnotationConfigServletWebServerApplicationContext 를 기반으로 애플리케이션을 구동한다.

기대하는 공통 포멧: 
[UUID][requestURL] {message}

UUID를 사용해서 HTTP 요청을 구분하자.

requestURL 정보도 추가로 넣어서 어떤 URL을 요청해서 남은 로그인지 확인하자. 

생존주기는 리퀘스트가 들어온 시점에서 생성돼서 끝날 때까지인데, 리퀘스트 들어오기 전에 요구하면, 오류가 난다.
-> 이를 해결하기위해서 provider를 사용한다.

provider를 이용하면 getObject() 를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다. getObject()를 호출하는 시점에는 HTTP 요청이 진행중이므로 문제없이 request scope 빈의 생성이 정상적으로 처리된다. 또한 같은 HTTP 요청인 경우에는 어디서 호출해도 같은 스프링 빈이 반환된다.

프록시
proxyMode = ScopedProxyMode.TARGET_CLASS 
를 추가
가짜를 만드는 것이다.
proxyMode = ScopedProxyMode.’적용대상’
‘적용대상’이
클래스 - TARGET_CLASS
인터페이스 - INTERFACES
를 선택한다.

이렇게 설정하면 가짜 프록시 클래스를 만들어서 주입을 해준다. CGLIB이라는 바이트코드를 조작하는 라이브러리를 사용해서 가짜 프록시 객체를 만든다. 그리고 스프링 컨테이너에 내가 만든 이름이 아니라 가짜 프록시 객체를 등록한다.  그래서 의존관계 주입도 이 가짜에 주입된다.
그리고 이 가짜 프록시 객체는 요청이 오면 내부에서 진짜 빈을 요청하는 위임 로직이 있다.

클라이언트가 진짜를 호출하면 가짜가 호출되고, 가짜같은 애가 로직을 호출하면 얘가 내부적으로 진짜를 찾아와서 진짜 로직을 호출해준다. 가짜는 원본 클래스를 상속 받아서 만들어졌기 때문에, 이 객체를 사용하는 클라이언트는 이게 가짜인지 아닌지 모르게 동일하게 사용할 수 있다.
가짜는 실제 request scope과는 관계가 없다. 그냥 내부에 단순한 위임 로직만 있다.
솔직히 provider나 프록시의 역할은 진짜 객체 조회를 요청이 들어오는 시점까지 지연처리한다.

가짜를 만들고 돌아간다. -> 클라이언트 코드를 전혀 고치지않는다. 
싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 주의해서 사용해야한다.

이런 특별한 스코프는 최소화해서 사용하는 것이 좋다.
