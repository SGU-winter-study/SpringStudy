# 연관관계 매핑
객체와 테이블 연관관계의 차이를 이해해야한다.
객체의 참조와 테이블의 외래 키를 매핑한다.

기본 용어
방향 : 단방향, 양방향
다중성 : 다대일, 일대다, 일대일, 다대다

연관관계의 주인: 객체 양방향 연관관계는 관리 주인이 필요

## 연관관계가 필요한 이유
자율적인 객체들의 협력 공동체를 만들기 위해서.

객체를 테이블에 맞춰서 데이터 중심으로 모델링을 하면 외래키를 사용해서 조인을 해 연관된 테이블을 찾아야하는데, 객체는 참조를 사용해서 연관된 객체를 찾는다. 이러한 차이때문에, 협력 관계를 만들 수 없다.
## 단방향 매핑
### 객체지향스럽게 모델링하기

@ManyToOne
@JoinColumn(name=“TEAM_ID”)
와 같이 관계형을 설정해주고 조인할 컬럼을 지정해주면 연관관계 매핑이 끝난다.

메서드를 이용해서 객체지향스럽게 CRUD를 할 수 있다. 특히 조회 같은 경우에는 영속성 컨텍스트 안에서 관리를 하기 때문에, 디비에 1차캐시에서 조회가 가능하다는 장점이 있다.

## 양방향 연관관계와 연관관계의 주인
객체 간에 양방으로 참조해서 오갈 수 있게 만들어주는 것.
PK랑 외래키로 JOIN하면 됨.
테이블의 연관관계에는 방향이라는게 없고 FK만 넣어놓으면 양방으로 다 알 수 있다.
여기서 문제는 객체다. 객체는 양쪽에 세팅을 해줘야지만 양쪽으로 오갈 수 있다.
객체에 List를 포함시킬 때는 ArrayList<>()로 초기화해주는 것이 관례

@ManyToOne을 이용한 것과 함께
@OneToMany(mappedBy = “team”)
사용.
mappedBy는 반대쪽에는 뭐로 매핑이 되어있음을 의미
### 객체와 테이블간의 연관관계를 맺는 차이를 이해해야한다.
테이블의 연관관계에는 방향이라는게 없고 FK만 넣어놓으면 양방으로 다 알 수 있다.
여기서 문제는 객체다. 
객체는 양쪽에 세팅을 해줘야지만 양쪽으로 오갈 수 있다.
= 객체의 양방향 관계는 양방향이 아니라 서로 다른 단방향 관계 2개다.
각각에다 참조할 것을 만들어놔야하기때문.
객체의 두 관계 중 하나를 연관관계의 주인으로 지정해준다.
주인만이 외래키를 등록, 수정하는 등의 관리를 한다. 주인이 아닌 쪽은 읽기만 가능하다.
주인은 mappedBy를 사용하면 안되고, 주인이 아니면 mappedBy를 사용해서 주인이 누구인지 알려줘야한다.

그렇다면 누가 주인이 되어야할까??
테이블 상 외래키가 있는 곳을 주인으로 정해라.
DB입장에서 보면 외래키가 있는 곳이 무조건 일대다에서 다에 해당한다.
즉, ManyToOne에서 Many에 해당하는 쪽이 연관관계의 주인이 되어야한다.

연관관계의 주인에 값을 입력하지않는 실수가 정말 많다.
연관관계의 주인에 값을 입력해줘야함을 잊지말자.

순수한 객체 관계를 고려하면 항상 양쪽 다 값을 입력해야한다.

flush(), clear()를 안하면  영속성 컨텍스트에 들어가있는 상태로 1차 캐시에 로딩되어져있는 데이터를 가지고 동작을하게된다.

그렇기 때문에, 양방향 연관관계를 설정할 때는 양쪽에다가 값을 세팅해줘야한다.

연관관계 편의 메서드
세팅을 해줄 때, 값을 연관관계가 있는 쪽에도 세팅이 되도록 해준다. 이렇게하면 실수가 줄어든다. 
로직이 들어가는 경우에는 set이라는 이름을 붙이기보다는 change등과 같은 이름을 붙여줘서 setter와 구분해서 사용하면 혼동이 줄어들 것이다.


