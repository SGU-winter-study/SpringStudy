# 엔티티 매핑 소개
## 객체와 테이블 매핑: @Entity, @Table
### @Entity
JPA에서 중요한 개념. 이게 붙은 클래스는 JPA가 관리하는 엔티티다.
그래서 JPA를 사용해서 테이블과 매핑할 클래스는 @Entity는 필수사항이다.
#### 주의사항
기본 생성자(파라미터가 없는 public 또는 protected 생성자)가 필수
final 클래스, enum, interface, inner 클래스에는 사용이 불가능하다.
디비에 저장하고싶은 필드에 final 사용은 안된다.
#### Entity 속성 정리
클래스 이름을 그대로 사용하는게 기본값이다.
### @Table
엔티티와 매핑할 테이블을 지정해준다.
name, catalog, schema, uniqueConstraints(DDL)

## 데이터 베이스 스키마 자동 생성
JPA가 매핑 정보만 보면 어떤 쿼리를 만들어야할지 알 수 있다. 그래서 JPA에서는 애플리케이션 로딩 시점에 디비 테이블을 생성하는 기능을 지원해준다.(이거는 개발 단계에서만 도움이 된다. 운영단계에서는 절대 사용하면 안된다)
DDL을 애플리케이션 실행 시점에 자동생 성해서 테이블 중심에서 객체 중심으로 바꿔준다.
데이터베이스 방언을 활용해서 디비에 맞는 DDL을 생성해준다. 이렇게 생성된 DDL은 반드시 개발 장비에서만 사용한다.
[image:356305C5-93D6-4BA1-890F-A153439D56C4-22836-000013DE7CEE1B03/스크린샷 2021-01-24 오후 11.04.09.png]
지우는건 불가능하다. 그 이유는 실제 테이블의 컬럼이 손상되면 안되기때문.

제약조건 추가
@Column(제약조건)
필수인 경우는 nullable=false 
길이는 10이하여야하면 length = 10 과같이 설정해줄 수 있다.
DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA 실행 로직에는 영향을 주지않는다.
# 주의
운영 장비에는 절대 create, create-drop, update를 사용하면 안된다.
개발 초기 단계에는 create 또는 update
테스트 서버는 다른 개발자들이 생성해놓은 데이터가 날라가고 할 수 있기 때문에, update나 validate를 권장한다.

스테이징이나 운영서버 같은 경우는
validate 또는 none을 사용하는 것이 좋다.

update하고나 create를 하는 경우에는 디비를 디비에 락이 걸리거나하는 등의 서비스 중지가 있을 수 있다.

## 필드와 컬럼 매핑: @Column
## 기본 키 매핑: @Id
## 연관관계 매핑: @ManyToOne,@JoinColumn

# 필드와 컬럼 매핑
## 매핑 어노테이션 
### @Column
매핑해줄 컬럼을 지정해준다.
1. name
2. insertable,updatable
기본이 true다. 
3. nullable(DDL)
null 값의 허용 여부를 설정. 디비 스키마 설계할 때 사용하는 not null에 해당하는 내용이다.
4. unique(DDL)
잘 안쓴다. 그 이유는 이름을 반영하기 어렵다. 이 조건은 @Table 안에다 걸어주는게 예외가 발생했을 때, 대응하기가 쉬워진다.
5. columnDefinition(DDL)

6. length(DDL)
7. precision, scale(DDL)
BigDeciaml 타입에서 사용. 아주 큰 숫자나 소숫점 다룰 때 쓰면 좋다.
### @Temporal
날짜의 타입을 매핑(날짜, 시간, 날짜시간)
JAVA 8 시대에 들어오면서 따로 쓸 필요가 없어졌다. 최신 하이버네이트에서 지원을 해준다.
### @Enumerated
Enum 쓰고 싶을 때 사용
ORDINAL은 사용하면 안된다.
그 이유는 항목이 추가되어서 순서가 바뀐 경우에 심각한 오류가 발생한다. 
1. ORDINAL -  enum 순서를 디비에 저장
2. STRING - enum 이름을 디비에 저장

### @Lob
데이터베이스에 varchar를 넘어서는 큰 컨텐츠를 넣고싶을 때 Lob을 쓰면 된다.
문자 타입이면 기본으로 clob으로 생성된다. 그 이외에는 blob으로 매핑된다. 그래서 지정해줄 수 있는 속성이 없다.

### @Transient
매핑 안하고싶을 때, DB랑 관계없이 메모리에서만 쓰고싶을 때 붙여준다.

# 기본 키 매핑
## @Id
직접 할당
## @GeneratedValue
@GeneratedValue(strategy = GenerationType.설정값) 과 같이 쓴다.
### IDENTITY : 
기본 키 생성을 데이터베이스에 위임한다. 
MYSQL에 데이터 넣으면 자동으로 붙여준다. autoincrement를 이용해서 순차적으로 올라가게 설정한다.
ID 값을 알 수 있는 시점은 디비에 들어가봐야 알 수 있다. JPA에서 관리하려면 영속성 컨텍스트에서 관리되려면 pk값이 있어야하는데, 이 pk값이 디비에 들어가봐야 알 수 있다. 그렇기 때문에 이 경우에는 persist를 호출하는 시점에 실제 디비에 insert쿼리를 날려준다. 

### SEQUENCE: 
데이터베이스 스퀀스 오브젝트를 사용한다. 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트다. 
주로 오라클에서 많이 사용(오라클, PostgreSQL,DB2, H2 DB에서 사용)
persist()를 호출하면 시퀀스에서 pk를 가져온다. 쿼리를 날리는데 “call next value for 시퀀스 이름”을 날려서 값을 얻어와서 영속성 컨텍스트에 넣어둔다. 시퀀스 방식에서는 버퍼링 형식이 가능하다.

#### @SequenceGenerator가 필요
테이블마다 시퀀스를 따로 관리하고 싶을 때, 이용해서 매핑을 해주면 된다.
1. name -식별자 생성기 이름
2. sequenceName - 디비에 동록되어있는 시퀀스 이름
3. initialValue - DDL 생성 시에만 사용되는 것으로 시퀀스 DDL을 생성할 때 처음 1 시작하는 수를 지정한다.
4. allocationSize - 시퀀스 한번 호출에 증가하는 수(기본값이 50)디비 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 반드시 이 값을 1로 설정해줘야한다.) 
성능 최적화를 위한 방법. - 저장을 할 때마다 next call로 가져오면 네트워크를 계속 타야하는 성능 문제가 있다. allocationSize로 미리 땡겨와서 메모리에 가지고 있으면서 메모리에서 1씩 쓰다가 모자르면 더 가져오는 방식을 사용해서 사용이 가능하다.(ex. allocationSize = 50인 경우 50개 가져와서 메모리에 놓고 쓰다가 51번째를 만나는 순간 미리 50개를 더 가져와서 쓰는 방식이라고 이해하면 된다.)
동시성 이슈 없이 다양한 문제가 해결 가능하다.  맨 처음 더미로 1번 호출되는 경우가 있지만 그 이후에 한 번 더 호출해서 의도한대로 작동한다. 
5. catalog,schema - 디비 카탈로그, 스키마 이름

### TABLE: 
키 생성용 테이블을 사용한다. 키 생성 전용 테이블을 하나 만들어서 디비 시퀀스를 흉내내는 전략이다. 모든 디비에서 사용가능하다. 별도의 테이블이다보니 락이 걸리거나하고 다른 방법에 비해 최적화가 안되어있어서 성능이 좀 떨어진다.
시퀀스랑 비슷하게 쓴다.
@TableGenerator가 필요하다.
1. name -식별자 생성기 이름
2. table - 키 생성 테이블명
3. pkColumnName - 시퀀스 칼럼명
4. valueColumnNa - 시퀀스 값 칼럼명
5. pkColumnValue - 키로 사용할 값 이름
6. initialValue - DDL 생성 시에만 사용되는 것으로 시퀀스 DDL을 생성할 때 처음 1 시작하는 수를 지정한다.
7. allocationSize - 시퀀스 한번 호출에 증가하는 수(기본값이 50)디비 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 반드시 이 값을 1로 설정해줘야한다.) 시퀀스에서와 같은 전략으로 최적화가 가능하다.
8. catalog,schema - 디비 카탈로그, 스키마 이름
9. uniqueConstraint(DDL) - 유니크 제약 조건을 지정할 수 있다.
운영에서는 디비에서 관례로 쓰는 것이 있기 때문에 테이블 전략을 사용하는 것은 약간 껄끄러운 점이 있어서 잘 쓰지않는다. 


### AUTO - 방언에 따라서 자동 지정해준다. 별도의 설정이 없으면 이걸 기본값으로 한다.(1,2,3 중에서 하나 고르는 것이다.)

## 권장하는 식별자 전략
변하면 안된다는 제약 조건이 제일 중요하다.
아주 먼 미래까지 null이 아니면서 유일하고 변하면 안되는 자연키를 찾기 어렵다. 그렇기 때문에 대리키를 사용한다. 비즈니스와 전혀 상관없는 값을 사용하는 것을 추천한다.

Long형 + 대체키 + 키 생성전략 사용하는 방식을 권장한다.
