## 프로토타입 스코프 

### 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

스프링 컨테이너에 프로토타입 빈을 요청하면 항상 새로운 객체 인스턴스를 생성해서 반환한다. 프로토타입 빈을  사용하는 이유도 결국 매번 새로운 객체를 사용하기 위해서. 

그런데 싱글톤 빈이 의존관계 주입을 통해서 프로토타입 빈을 주입받아서 사용할 때는 문제가 발생한다.  스프링 컨테이너 생성 시점에 싱글톤은 같이 생성되고 의존관계 주입도 발생하는데 주입 시점에 스프링 컨테이너에 프로토타입 빈을 요청하게 된다. 그 때 스프링 컨테이너는 프로토타입 빈을 생성해서 싱글톤에 반환한다. 

이 싱글톤 빈을 여러 클라이언트가 요청해서 받을 때 싱글톤이니까 항상 같은 객체를 받게 된다. 그런데 내부 프로토타입 빈은 과거에 이미 주입이 끝나 사용할 때마다 새로운 객체가 생성되지 않는다. 

그러면 프로토타입 빈을 사용하는 이유가 사라지니까 해결 방법?

### 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결

- 싱글톤 빈이 프로토타입을 사용할 때마다 스프링 컨테이너에 새로 요청. 즉, 스프링 애플리케이션 컨텍스트 전체를 주입으로 해결할 수 있다. 의존관계조회(Dependency Lookup(DL)). BUT 스프링 애플리케이션 컨텍스트 전체를 주입받게 되면 스프링 컨테이너에 종송적인 코드가 되고 단위 테스트도 어려워진다. 

- ObjectFactory, ObjectProvider : 지정된 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공한다. Factory가 부모 인터페이스, Provider는 그걸 상속받고 추가적인 기능이 있는 인터페이스. 스프링에 의존적이다.

  ObjectProvider 의 getObject() 를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL) 항상 새로운 프로토타입 빈이 생성되어 반환된다. 

- JSR-330 Provider : provider 의 get() 을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL) 자바표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다. 기능이 get() 메서드 하나로 매우 단순하다. 

실무에서는 싱글톤 빈으로 대부분의 문제 해결 가능해서 프로토타입 빈을 직접 사용할 일은 거의 없다. 프레임워크나 다른 코드들 분석할 때 정도? ObjectProvider, JSR330 Provider는 이 뿐만 아니라 DL이 필요한 경우에도 사용할 수 있다.ㄴ

### 웹 스코프

특징

- 웹 환경에서만 동작한다. 
- 프로토타입과 다르게 스프링이 해당 스코프의 종료 시점까지 관리해서 종료 메서드가 호출된다.

종류: request, session, application, websocket

여기서는 request 중심으로. request는 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.

### request 스코프 예제

동시에 여러 HTTP 요청이 올 때 정확히 어떤 요청이 남긴 로그인지 구분하기 위해서 request 스코프 활용할 수 있다. 로그를 출력하는 기능을 구현해서 실행하려고 하는데 문제가 발생했다.

스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만, request 스코프 빈은 아직 생성되지 않는다. 이 빈은 실제 고객의 요청이 와야 생성할 수 있기 때문에

##### 첫번째 해결책은 Provider 사용

```java
private final ObjectProvider<MyLogger> myLoggerProvider;
MyLogger myLogger = myLoggerProvider.getObject();
```

ObjectProvider를 활용하면 ObjectProvider.getObject() 를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다.
ObjectProvider.getObject() 를 호출하시는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리된다.

ObjectProvider.getObject() 를 LogDemoController , LogDemoService 에서 각각 한번씩 따로 호출해도 같은 HTTP 요청이면 같은 스프링 빈이 반환된다!

##### 두번째 해결책은 프록시 방식

```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyLogger {
}
```

위 코드를 통해 MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해놓을 수 있다. 

CGLIB 라이브러리로 만들어진, 내 클래스를 상속 받은 가짜 프록시 객체가 스프링 컨테이너에도 등록되고 의존관계 주입에도 사용된다.  가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다. 가짜 프록시 객체는 실제 requeset 스코프와는 관계없고 싱글톤처럼 작동한다.

두 해결책의 핵심은 진짜 객체 조회를 꼭 필요한 시점까지 지연시켜 처리한다는 것이다.

싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 주의해서 사용해야 하고 이러한 특별한 scope는 꼭 필요한 곳에 최소화해서 사용해야 한다!!
