## 스프링 컨테이너와 스프링 빈

### 스프링 컨테이너 생성

ApplicationContext를 스프링 컨테이너라 한다. 이는 인터페이스이다. (다형성 활용 가능)

스프링 컨테이너는 XML 기반으로 만들 수도 있고 애노테이션 기반 자바 설정 클래스로 만들 수 있다.

```java
new AnnotationConfigApplicationContext(AppConfig.class);
```

1. 스프링 컨테이너 생성

   위 코드로 스프링 컨테이너를 생성할 수 있다. 스프링 컨테이너를 생성할 때는 구성정보를 지정해줘야 하는데 여기서는 AppConfig.class로 지정했다. 또한 스프링 컨테이너 안에는 스프링 빈 저장소가 있고 이는 빈 이름과 빈 객체로 구성되어 있다.

2. 스프링 빈 등록

   파라미터로 넘어온 설정 클래스 정보를 활용해서 @Bean이 붙은 메소드를 모두 호출한다. 그리고 메소드 이름을 키, 반환하는 객체를 빈 객체로 해서 스프링 빈을 등록한다. **빈 이름은 항상 다른 이름으로 부여**해야한다. 

3. 스프링 빈 의존관계 설정

   설정 정보를 참고해서 의존관계를 주입(DI)한다. 객체 참조 값들의 연결.

### 컨테이너에 등록된 모든 빈 조회

ac.getBeanDefinitionNames() : 스프링에 등록된 모든 빈 이름을 조회한다.

ac.getBean() : 빈 이름으로 빈 객체(인스턴스)를 조회한다.

스프링이 내부에서 사용하는 빈은 getRole() 로 구분할 수 있다.

ROLE_APPLICATION : 일반적으로 사용자가 정의한 빈

ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈

### 스프링 빈 조회 - 기본

이름으로 조회, 타입으로 조회(인터페이스), 구체 타입으로 조회(구현체, 유연성이 떨어짐)가 있다. 

- ac.getBean(빈이름, 타입)

- ac.getBean(타입)

조회 대상 스프링 빈이 없으면 NoSuchBeanDefinitionException 예외 발생. Assertions.assertThrows로 예외 받아주는데 테스트 코드에서는 이렇게 실패할 때의 코드도 작성해야 한다. 

### 스프링 빈 조회 - 동일한 타입이 둘 이상

타입으로 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생한다. 이때 빈 이름을 지정해서 조회해야 한다. 

ac.getBeansOfType() 을 사용하면 해당 타입의 모든 빈을 조회할 수 있다. 이를 Map 자료형 변수에 담아서 key는 메소드명, value는 객체로 받는다. 

### 스프링 빈 조회 - 상속관계

**기본 대원칙 : 부모 타입으로 조회하면, 자식 타입도 함께 조회한다.  자식 타입은 다 끌려 나온다** 

모든 자바 객체의 최고 부모인 'Object' 타입으로 조회하면 모든 스프링 빈을 조회한다. 

부모 타입으로 조회시 자식이 둘 이상 있으면 중복오류 발생. 따라서 빈 이름 지정해야 한다.  아니면getBeansofType()으로  모두 조회해서 Map으로 받거나. 

애플리케이션 개발 단계에서 getBean 직접 쓸 일 적기는 하지만 알아두면 좋다. 기본적인 기능.

테스트 코드 작성할 때 print해서 눈으로 보는 것도 좋지만 시스템이 알아서 판단하게 하는 게 좋다. 

자주 쓰는 것 : assertThat(객체).isInstanceOf(타입.class); 이 타입의 인스턴스인지 판단.  assertThat().isEqual() : 앞에서 참조하는 값이 뒤와 같은지 판단. asserThat().isSameAs(): 주소가 같은지 판단. 

same: 자바에서 == 객체의 주소 비교 , equal : 자바에서 equals() 객체의 내용 비교

### BeanFactory와 ApplicationContext

- BeanFactory : 스프링 컨테이너의 최상위 인터페이스, 스프링 빈을 관리하고 조회하는 역할을 담당한다. getBean()과 같은 대부분의 기능을 제공한다.
- ApplicationContext: BeanFactory의 기능을 모두 상속받아서 제공한다. 거기에 일반적으로 애플리케이션 개발에 필요한 부가기능을 더해준다. 메시지소스를 활용한 국제화 기능, 환경변수, 애플리케이션 이벤트, 편리한 리소스 조회. 

BeanFactory를 사용할 일은 거의 없고 ApplicationContext를 사용한다. 둘다 스프링 컨테이너라고 부른다. 

### 다양한 설정 형식 지원 - 자바코드, XML

스프링 컨테이너는 다양한 형식의 설정 정보를 받아들일 수 있게 유연하게 설계되어 있다. 

애노테이션 기반 자바 코드 설정(최근 대부분)

```java
new AnnotationConfigApplicationContext(AppConfig.class);
```

 XML 설정 사용(과거에 사용)

### 스프링 빈 설정 메타 정보 - BeanDefinition

BeanDefinition(빈 설정 메타정보)이라는 추상화를 통해 다양한 설정 형식을 지원할 수 있다. 

**역할과 구현을 개념적으로 나눈 것**

@Bean당 하나씩 메타 정보가 생성된다. 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다. 스프링 컨테이너는 BeanDefinition(인터페이스, 추상화)에만 의존한다.

실무에서 BeanDefinition을 직접 정의하고 사용할 일은 거의 없다. 

## 싱글톤 컨테이너

### 웹 애플리케이션과 싱글톤

스프링을 활용하지 않으면 클라이언트가 요청을 보낼 때마다 DI 컨테이너에서 요청을 받고 매번 객체 생성해서 반환.  웹 애플리케이션은 고객의 요청이 매우 많은데 매번 객체를 생성하고 소멸하고 하면 메모리 낭비가 심하다. 따라서 해당 객체가 1개만 생성되고 공유하도록 한다 -> 싱글톤 패턴

### 싱글톤 패턴

클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.  객체 인스턴스 2개 이상 생성하지 못하도록 막아야 한다. 싱글톤 패턴을 구현하는 방법은 다양하지만 단순하고 안전한 방법은 아래와 같다.

1. static 영역에 객체 instance를 미리 생성해서 올려둔다.
2. 객체 인스턴스가 필요하면 오직 getInstance() 메소드를 통해서만 조회할 수 있다. 
3. 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 private으로 막아서 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.

하지만 싱글톤 패턴 문제점이 많다. 구현 코드가 많이 들어가고 의존관계상 클라이언트가 구체 클래스에 의존해 DIP를 위반 등등등 결국 유연성이 떨어진다.

### 싱글톤 컨테이너

스프링 컨테이너가 싱글톤 컨테이너의 역할을 한다. 싱글톤 패턴의 문제를 해결하면서 객체 인스턴스를 싱글톤(1개)으로 관리한다. 

지금까지 사용한 스프링 빈이 싱글톤으로 관리되는 빈이다. 클라이언트의 요청이 오면 스프링 빈 등록할 때 추가한 빈 객체만을 반환함.

### 싱글톤 방식의 주의점

싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지하게 설계하면 안된다.  스프링 빈의 필드에 공유값을 설정하면 큰 장애 발생할 수 있다.

스프링 빈은 항상 무상태(stateless)로 설계해야한다. 

 - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
 - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다
 - 가급적 읽기만 가능해야 한다
 - 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다. 

### @Configuration과 싱글톤

AppConfig를 보면 여러 번 메소드를 호출하면서 객체를 여러 개를 생성하는 것처럼 보인다. 어떻게 해결?! 

예시에서 memberRepository 인스턴스는 모두 같은 인스턴스가 공유되어 사용된다. 스프링 빈을 생성할 때 여러 번 메소드가 실행되어야 할 것 같은데 로그로 확인해보면 한번씩만 호출된다. 

### @Configuration과 바이트코드 조작의 마법

스프링 컨테이너는 싱글톤 레지스트리이기 때문에 스프링 빈이 싱글톤이 되도록 보장해주어야 한다. 하지만 자바 코드를 거스를 수는 없는데 이 때문에 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.  @Configuration을 적용한 AppConfig에 비밀이 있다.

AppConfig를 그대로 스프링 빈에 등록하는게 아니라 CGLIB이라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 클래스를 만들어 그것을 스프링 빈으로 등록한다.  그 다른 클래스가 싱글톤이 보장되도록 해준다. 

@Configuration 적용 안하고 @Bean만 적용하면  AppConfig가 그대로 스프링 빈에 등록되고 메소드도 여러 번 호출된다. 그래서 싱글톤이 깨지게 된다. 

스프링 설정 정보에는 항상 **@Configuration**을 사용하자



