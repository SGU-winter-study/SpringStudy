<h1>스프링 핵심원리 - 5일차(컴포넌트 스캔 ~ 의존관계 자동주입) </h1>

## Section 6. 컴포넌트 스캔

* 컴포넌트 스캔 : 설정 정보가 없어도 자동으로 스프링을 등록하는 기능.
* 의존관계 자동 주입 : 의존관계를 수동으로 주입하지 않아도 @Autowired를 통해 자동으로 주입해 줌.

## 컴포넌트 스캔과 자동 주입 시작하기

- 1. 컴포넌트 스캔은 @Component를 포함하는 어노테이션(ex @Configuration)이 붙은 클래스를   
     스캔해서 스프링 빈으로 등록한다.

- 2. 기존에 Bean을 통해 직접 작성한 방법과 다르게 @Autowired를 통해 자동 의존관계 주입을 한다.

## 탐색 위치와 기본 스캔 대상

* 컴포넌트 탐색위치

- basePackages를 통해 component 스캔으로 탐색할 시작위치를 지정할 수 있다.

- 지정하지 않을 경우 @ComponentScan이 붙은 AppConfig(설정 정보)의 패키지가 시작 위치이다.

- 그래서 보통, AppConfig(설정 정보)를 프로젝트 최상에 둔다.

* 컴포넌트 기본 스캔 대상

- @Component를 포함하는 어노테이션을 가진 모든 클래스(ex. Controllor, Service, Configuration 등)

## 컴포넌트 필터, 중복 등록과 충돌

* 컴포넌트 필터

- includeFilters : excludeFilters = @MyIncludeComponent : @MyExcludeComponent 로 어노테이션
  만들어서 이용함.

* 중복 등록과 충돌

- 자동 vs 자동 : 컴포넌트 스캔을 통해 자동으로 빈이 등록되면 오류가 발생한다.

- 수동 vs 자동 : 수동이 더 우선순위에 있었으나, 애매한 오류가 발생하는 경우가 많아,
                오류가 발생하도록 변경되었다.

## Section 7. 의존관계 자동 주입

- 의존관계 자동 주입 : @Autowired를 이용한 주입을 보통 사용함.
- 의존관계 주입에는 생성자 주입, 수정자 주입, 필드 주입(잘 안씀), 일반 메서드 주입(잘 안씀)이 있다.

## 다양한 의존관계 주입 방법(@Autowired 이용)

1. 생성자 주입 : 생성자를 통해서 의존 관계 주입하는 방법으로, 불편&&필수 의존관계에 사용

2. 수정자 주입 : setter 메소드를 이용해서 의존관계를 주입하는 방법, 선택&&변경 의존관계에 사용

3. 필드 주입 : 필드에 바로 주입(변수에?)하는 방법, 효용성이 떨어져서 거의 사용안함.

4. 일반 메소드 주입 : 스프링 빈일 때, 메소드 위에 어노테이션 추가

* 옵션 처리 : 옵션 처리를 하는 3가지 방법 @Autowired(required=false), @Nullable, Optional<>

1. @Autowired(required=false) : 메서드가 아예 호출이 안됨.

2. @Nullable : 호출은 되고 NuLL 값을 반환한다.

3. Optional : 호출은 되고 Optional.empty값을 반환한다.

## 생성자 주입을 선택해라!!
: 위에서 4가지 의존관계 주입 방법을 알아봤으나 DI 프레임워크에서는 생성자 주입을 권장한다.

* 이유

1. 대부분 어플리케이션 종료 시전까지 의존관계 변경할 필요가 없다.

2. Setter 주입 이용시 접근이 가능해서 원래 값이 수정될 여지가 있다(실수 가능성)

3. 생성자 주입은 1번만 하면되므로 불변하게 설계 가능하다.

4. 생성자 주입시 컴파일 오류를 통해서 왜 오류가 났는지 빠르게 파악이 가능하다.

5. 만일 불가피하게 옵션이 필요하다면 수정자 주입을 이용하면 된다.

## 롬복에 대한 간단한 설명
: 롬복은 좀 더 편리하게 어노테이션을 활용하여 코드작성을 할 수 있도록 도와주는 라이브러리이다.

* 롬복의 기능

1. @Getter/@Setter -> getter/setter 자동 생성
2. @ToString ... 등등 으로 메소드 생성
3. @RequiredArgsConstructor 기능을 통해 생성자 자동생성

-> 그래서 주로 생성자를 하나만 두고 @Autowired를 생략한뒤, Lombok을 이용해서 코드를 작성한다.

## 조회 빈이 2개 이상시 해결 방안
: 조회 빈이 2개 이상일때 @Autowired 필드명 매칭, @Qualifier 매칭, @Primary 이용을 통해 해결 가능하다.

1. @Autowired 필드 명 매칭
    - 타입 매칭 -> 필드명 -> 파라미터명 순으로 2개 이상일 때 매칭.

2. @Qualifier 사용 : 추가 구분자인 Qualifier통해서 Qualifier가 붙은 값을 찾아서 매칭한다.
    - @Qualifier 끼리 -> 빈 이름으로 -> 예외 발생

3. @Primary 이용 : @Primary를 이용해서 우선순위를 정한다.

-> 그래서 Main의 경우 Primary로 Sub의 경우 Qualifier를 이용해서 처리해준다.

## 조회 빈이 모두 필요할 때 -> List, Map 이용
: 같은 타입의 스프링 빈이 모두 필요한 경우 Map/List를 이용해서 모든 Bean을 주입받고 클라이언트
  요청에 따라 필요한 빈만 호출할 수 잇도록 스프링이 지원한다.

## 실무 운영 기준
: 기본은 자동 주입, 필요한 경우 수동으로 빈 등록// 의존관계 주입하기.

1. 자동 빈과 수동 빈
    - 숫자가 많고, 유사한 패턴이 반복되는 업무로직은 자동 빈에 의해 관리된다.

    - 숫자가 적고, 광범위 하게 영향을 미치고, 에러 파악이 힘든 기술로직은 수동 빈등록으로 관리한다.

2. 비즈니스 로직에서 다형성 활용
    : 수동 빈으로 등록하거나 자동으로 할 시 특정 패키지에 빈을 묶어서 한눈에 최대한 파악되게 한다.

