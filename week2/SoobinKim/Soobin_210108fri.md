## 빈 생명주기 콜백
객체의 초기화와 종료 작업을 스프링을 통해 진행할 수 있음.

스프링 빈의 이벤트 라이프사이클:
1. 스프링 컨테이너 생성
2. 스프링 빈 생성
3. 의존관계 주입
4. 초기화 콜백
5. 사용
6. 소멸 전 콜백
7. 스프링 종료

## 빈 스코프
빈 스코프는 빈이 존재할 수 있는 범위를 의미한다. 스프링에서 지원하는 스코프의 종류는 다음과 같다.
- 싱글톤
: 스프링 컨테이너의 시작부터 종료까지 유지되는 가장 넓은 범위의 스코프
- 프로토타입
: 빈의 생성과 의존관계 주입까지만 관리하고 그 이후는 관리하지 않는 짧은 범위의 스코프
- 웹 관련 스코프
	- request
: 웹 요청(request)가 들어오고 나갈 때까지 유지되는 스코프
	- session
: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
	- application
: 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프

#### 프로토타입 스코프
스프링 컨테이너가 시작될 때부터 종료될 때까지 빈을 존재하도록 관리하는 싱글톤 스코프의 경우, 빈을 조회하게 될 경우 해당 빈이 계속 스프링 컨테이너 내부에 존재하고 있기 때문에 항상 같은 인스턴스의 스프링 빈을 반환한다는 사실은 자명하다. (조회하려는 타입의 빈이 스프링 컨테이너 내부에 계속 존재하고 있기 때문에)
그러나 프로토타입 빈 요청의 경우, 해당 빈을 요청했을 때 스프링 컨테이너에 빈을 생성하고, 생성한 빈을 반환한 후 더 이상 관리하지 않는다. 즉, 이후에 동일한 타입의 빈이 다시 요청되었을 때 새로운 빈이 다시 생성되어 반환되기 때문에 동일한 인스턴스가 반환되지 않는다.

핵심은, 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계를 주입하고, 초기화하는 것 까지만 관리하는 것이다. 반환된 빈에 대한 관리(ex. 종료)는 클라이언트에 의해 이루어진다.

그러나 싱글톤 빈과 프로토타입 빈을 동시에 사용하는 경우, 즉 프로토타입 빈을 싱글톤 빈에 주입하게 될 때에는, 싱글톤 빈의 생성 시점에만 의존관계 주입이 일어나게 되므로 싱글톤 빈은 계속 같은 인스턴스의 프로토타입 빈을 참조하게 된다. 따라서 이 경우에는 요청이 발생할 때마다 프로토타입 빈이 새로 생성되지 않는다는 의도에 어긋나는 상황이 발생한다.

이를 해결하기 위한 방법으로 직접 필요한 의존관계를 찾는 DL(Dependency Lookup)을 사용할 수 있다.
* ObjectFactory
* ObjectProvider
: ObjectFactory를 상속받아 부가 편의기능이 존재한다.

```java
@Autowired
private ObjectProvider<PrototypeBean> prototypeBeanProvider;

public int logic() {
	PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
	...
}
```
.getObject() 호출로 인해 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아 반환한다.

그러나 이 방법은 스프링에 의존적이기 때문에, 스프링을 사용할 때만 작동한다.
스프링에 의존하지 않고 DL을 수행하는 방법으로는 Provider를 이용하는 것이 있다.

```java
// implementation 'javax.inject:javax.inject:1' gradle 추가 필요
@Autowired
private Provider<PrototypeBean> provider;

public int logic() {
	PrototypeBean prototypeBean = provider.get();
	...
}
```

#### 웹 스코프
웹 환경에서만 동작하는 스코프로, 종료 메소드가 호출되어 해당 스코프가 종료될 때까지 빈을 관리한다.
1. Request
: HTTP request 가 들어오고 나갈 때까지 유지되는 스코프이다. 각각의 요청마다 별도의 빈이 생성된다.
2. Session
3. Application
4. Websocket
: 웹 소켓과 동일한 생명주기를 갖는 스코프이다.

Request 스코프의 경우, 사용자로부터 실제 요청이 들어오기 전까지는 빈이 생성되지 않는다. 그렇기 때문에 생성자 주입에서 오류가 발생할 수 있다(주입하고자 하는 빈이 스프링 컨테이너에 아직 존재하지 않기 때문에). 이를 해결하기 위해 *진짜 객체가 꼭 필요한 시점까지 해당 객체의 조회를 지연*하는 방식을 사용할 수 있다. 이를 위해 사용되는 방식은 크게 다음과 같다.
* Provider
: 사용자로부터 요청이 들어오는 시점에 .get() 메소드를 활용하여 진짜 객체의 의존관계 주입을 수행한다. 그 전까지는 Provider를 사용하여 임시 할당해둔다.
* Proxy
: 스프링에 의해 생성된 '가짜 객체'를 실제 요청이 들어오기 전까지 할당해둔다. 실제 요청이 들어와 '진짜 객체(Request 스코프로 정의된 빈)'를 조회해야 하는 경우 프록시 객체(가짜 객체)가 알아서 진짜 객체를 찾아 메소드를 호출해준다. 이는 프록시 객체가 진짜 객체를 상속받기 때문에 가능한 것으로, 클라이언트는 해당 객체가 가짜인지 진짜인지를 신경쓰지 않아도 된다는 점에서 다형성이 보존된다.

