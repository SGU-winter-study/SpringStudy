# 의존관계 자동 주입
## 생성자 주입을 선택하자!!
대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다. 
객체를 생성할 때 딱 1번만 호출되기 때문에 이후에 호출되는 일이 없다.
-> 불변하게 설계가 가능
테스트 짤 때, 생성자 주입을 이용하면 컴파일 오류를 통해서 오류를 인지할 수 있다. 
final 키워드를 이용할 수 있다. -> 한 번 생성할 때 넣어주면 안바뀌기 때문에, 초기값을 넣어주거나 생성자를 통해서만 값을 넣어줄 수 있다.
-> 이렇게되면 실수로 생성자의 코드를 누락한 경우에, final을 이용해서 생성자에서 코드가 누락되거나 문제가 생긴 부분을 알 수 있다.

생성자 주입은 프레임워크에 의존하지않고 순수한 자바 언어의 특징을 잘 살리는 방법이다. 기본으로 생성자 주입을 이용하고, 필수 값이 아닌 경우나 옵션이 필요한 경우에만 수정자 주입을 사용한다.
### 생성자 주입
생성자를 이용해서 의존 관계를 주입받는 방법이다.
생성자 호출 시점에 딱 1번만 호출되는 것이 보장된다.
불변, 필수 의존관계에 사용
좋은 개발 습관은 한계점과 제약을 잘 두는 것이다.
스프링 빈인데 생성자가 딱 하나인 경우는 @Autowired 가 자동으로 적용된다.
얘는 빈을 등록하면서 클래스 콜하니까 자바 문법에 따라서 생성자가 호출되면서 자동으로 주입되는 것이다.

### 수정자 주입
setter을 이용
setter 라 불리는 필드의 값을 변경하는 수정자 메서드를 이용해서 의존관계를 주입한다.
선택적이고, 변경 가능성이 있는 의존 관계에 사용한다. 
@Autowired 의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false) 로 지정 

중간에 의존성을 바꾸고 싶으면 외부에서 수정자를 강제로 호출하면 된다.
컨테이너를 만들고 빈을 등록한 다음에, 의존관계 설정을 준비한 후에, 의존관계를 주입하는 단계가 따로 있었는데, 이때 일어나는게 수정자주입을 통한 방법이다.
자바빈 프로퍼티 규약을 따른다. 
자바빈 프로퍼티, 자바에서는 과거부터 필드의 값을 직접 변경하지 않고, setXxx, getXxx 라는 메서 드를 통해서 값을 읽거나 수정하는 규칙이다.

### 필드주입
코드가 간결해서 좋아보이지만 외부에서 변경이 불가능해 테스트가 힘들고, DI 프레임워크가 없으면 아무것도 할 수 없다.
-> 사용하지말자

일반 메서드 주입
일반 메서드를 통해서 주입하는데, 보통 생성자 주입이나 수정자 주입 선에서 다 해결하기 때문에, 많이 쓰지않는다. 그리고 ㅈ의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 작동하기때문에, 스프링 빈이 아닌 클래스에서 @Autowired 코드를 적용해도 아무 기능도 동작하지않는다.

## 옵션 처리
주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
그런데 @Autowired 만 사용하면 required 옵션의 기본값이 true 로 되어 있어서 자동 주입 대상이 없 으면 오류가 발생한다. 
자동 주입 대상을 옵션으로 처리하는 방법은 다음과 같다.
@Autowired(required=false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨 
org.springframework.lang.@Nullable : 자동 주입할 대상이 없으면 null이 입력된다. 
Optional<> : 자동 주입할 대상이 없으면 Optional.empty 가 입력된다. 

## 롬복과 최신 트랜드
롬복의 대표적인 기능
@Getter, @Setter 애노테이션을 붙여주면 알아서 getter setter 수정자를 만들어서 쓴다.
@ToString 예쁘게 출력하는거 도와줌.
@RequiredArgsConstructor : final이 붙은 필수값들을 가지고 생성자를 만들어준다.
최근에는 생성자를 하나만 적용해서 @Autowired를 제거하고 @RequiredArgsConstructor을 이용해서 코드를 깔끔하게 사용한다.

## 조회할 빈이 2개 이상인 경우
해결 방법
### @Autowired 필드명 매칭
autowired는 타입 매칭을 시도하고 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가한다.

### @Qualifier
추가 구분자를 넣어주는 방식이다. @Qualifier가 붙은걸 못찾으면, 해당 구분자와 이름이 같은 스프링 빈을 추가로 찾는다. 
그래도 없으면 NoSuchBeanDefinitionException 이 터진다.

@Qualifier는 @Qualifier를 찾는 용도로만 사용하는게 좋다.
단점은, 주입 받을 때, 관련 코드에 모두 @Qualifier를 붙여줘야한다.

### @primary
붙은 것을 최우선으로 사용한다.

### @Primary vs @Qualifier
DB를 예로들면, 메인커넥션 획득은 @Primary를 이용하고, 서브 데이터베이스 커넥션 빈을 획득할 때, @Qualifier를 지정해서 명시적인 획등 방식을 사용해서 코드를 깔끔하게 만들 수 있다. 
@Primary는 기본값처럼 동작, @Qualifier 는 매우 상세하게 동작
스프링은 자세한 것이 우선권을 가져간다.(ex. 자동보다는 수동이 우선순위)

#### 애노테이션 직접 만들기
문자는 컴파일타임에 체크가 안된다. 그래서 @Qualifier(“mainDiscountPolicy”) 과 같이 적으면 버그가 생길 수 있다. 이는 애노테이션을 직접 만들어서 해결할 수 있다.
만들고 @Qualifier과 같이 사용할 수 있다. 왠만한거는 스프링이 제공하는 것 안에서 해결하는데, 문자를 넣어서 사용하는 것 같은 경우에는 이용하기 좋은데 무분별하게 사용하는 것은 좋지않다.
### 조회한 빈이 모두 필요한 경우에는 List, Map을 이용
map으로 주입을 받은 후에 파라미터가 넘어오면 map에서 그에 해당하는 스프링 빈을 찾아서 실행을 하는 로직이다.


# 단축키
option + command + v  자동으로 선언해줌.
command + fn +F12 : 네비게이터 보여줌.
command + O : 검색하고 검색결과로 이동.
command + option + B Navigate->Go to implementation
command + B 사용중인 메서드 추적.
