# 실전! 스프링 부트와 JPA 활용1 -  3일차(회원 도메인 개발 ~ 주문 도메인 개발)

애플리케이션 아키텍처는 Controller, service, repository, domain으로 이루어진 계층형 구조를 사용한다. 

- controller, web: 웹 계층
- service: 비즈니스 로직, 트랜잭션 처리
- repository: JPA를 직접 사용하는 계층, 엔티티 매니저 사용
- domain: 엔티티가 모여 있는 계층, 모든 계층에서 사용

## 회원 도메인 개발

### 회원 리포지토리 개발

- @Repository : 스프링 빈으로 등록, JPA 예외를 스프링 기반 예외로 예외 변환

- @PersistenceContext : 엔티티 메니저( EntityManager ) 주입

- @PersistenceUnit : 엔티티 메니터 팩토리( EntityManagerFactory ) 주입

```java
public void save(Member member) {
em.persist(member); }
```

- save() : jpa의 persist 메서드. em을 통해 영속성 컨텍스트에 member 엔티티 넣고 트랜잭션 커밋되는 시점에 DB에 쿼리 날린다.

```java
public Member findOne(Long id) {
return em.find(Member.class, id);}
```

- findOne() : jpa의 find 메서드. 단건 조회 기능이다. 첫번째 타입, 두번째 primary key 넣어서 조회한다. 

- findAll() : createQuery해서 JPQL 만든다. JPQL은 SQL과 문법이 비슷하지만 from의 대상이 테이블이 아니라 엔티티다. 

- findByName() : 파라미터 바인딩해서 특정 이름인 회원 찾기

### 회원 서비스 개발

- @Service: 스프링 빈으로 등록.

- @Transactional : 트랜잭션, 영속성 컨텍스트 readOnly=true : 데이터의 변경이 없는 읽기 전용 메서드에 사용, 영속성 컨텍스트를 플러시 하지 않으므로 약간의 성능 향상(읽기 전용에는 다 적용), 디폴트는 false. 

- @Autowired : 생성자 Injection 많이 사용, 생성자가 하나면 생략 가능

- join() : 멤버를 입력받아 중복 회원을 검증한 뒤에 리포지토리에 멤버를 저장한다. 리턴값으론 id만.

- findMembers() : 멤버 리포지토리에서 전체 회원 조회한다.

- findOne() : 멤버 id를 받아서 멤버 리포지토리에서 id로 멤버를 찾는다.

- 의존관계 주입은 필드주입보다는 생성자 주입 사용! 
  - 변경 불가능한 안전한 객체 생성할 수 있다.
  - final 키워드 추가해 컴파일 시점에 오류를 체크할 수 있다. 
  - 스프링 데이터 JPA를  사용하면 EntityManger도 주입가능하다.
  - 생성자 위에 @Autowired or lombok 활용해 @RequiredArgsConstructor

### 회원 기능 테스트

- @RunWith(SpringRunner.class) : 스프링과 테스트 통합

- @SpringBootTest : 스프링 부트 띄우고 테스트(이게 없으면 @Autowired 다 실패)

- @Transactional : 반복 가능한 테스트 지원, 각각의 테스트를 실행할 때마다 트랜잭션을 시작하고 테스트가 끝나면 트랜잭션을 강제로 롤백. DB에 남는게 없다. 눈으로 보고 싶으면 @Rollback(false) 붙인다.

테스트는 격리된 환경에서 실행하고 끝나면 데이터 초기화하는게 좋으므로 메모리 DB를 사용하는 것이 이상적이다. 스프링 부트는 따로 설정이 없으면 기본적으로 메모리 DB를 사용한다.

## 상품 도메인 개발

### 상품 엔티티 개발

- addStock() 메서드는 파라미터로 넘어온 수만큼 재고를 늘린다. 이 메서드는 재고가 증가하거나 상품 주문을 취소해서 재고를 다시 늘려야 할 때 사용한다.
- removeStock() 메서드는 파라미터로 넘어온 수만큼 재고를 줄인다. 만약 재고가 부족하면 예외가 발생한다. 주로 상품을 주문할 때 사용한다.

객체지향적인 설계를 위해 밖에서 값을 바꾼다음에 넣는 것이 아니라 핵심 비즈니스 로직을 통해 stockQuantity의 값을 변경하고 비즈니스 로직은 그 데이터가 있는 곳에 위치하는 것이 좋다.

### 상품 리포지토리 개발

- save() : 상품의 id가 없으면 신규로 보고 persist() 실행. id가 있으면 이미 DB에 저장된 엔티티를 수정한다고 보고 merge() 실행. (update와 유사함)

### 상품 서비스 개발

상품 서비스는 상품 리포지토리에 단순히 위임만 하는 클래스이다.

## 주문 도메인 개발

#### 주문 엔티티 개발

- 생성 메서드( createOrder() ): 주문 엔티티를 생성할 때 사용한다. 그냥 만들기에는 복잡하기 떄문에 메서드를 따로 지정해준다. 주문 회원, 배송정보, 주문상품의 정보를 받아서 실제 주문 엔티티를 생성한다.
- 주문 취소( cancel() ): 주문 취소시 사용한다. 주문 상태를 취소로 변경하고 주문상품에 주문 취소를 알린다. 만약 이미 배송을 완료한 상품이면 주문을 취소하지 못하도록 예외를 발생시킨다.
- 전체 주문 가격 조회: 주문 시 사용한 전체 주문 가격을 조회한다. 전체 주문 가격을 알려면 각각의 주문상품가격을 알아야 한다. 로직을 보면 연관된 주문상품들의 가격을 조회해서 더한 값을 반환한다.

### 주문상품 엔티티 개발

- 생성 메서드( createOrderItem() ): 주문 상품, 가격, 수량 정보를 사용해서 주문상품 엔티티를 생성한다. 그리고 item.removeStock(count) 를 호출해서 주문한 수량만큼 상품의 재고를 줄인다.
- 주문 취소( cancel() ): getItem().addStock(count) 를 호출해서 취소한 주문 수량만큼 상품의 재고를 증가시킨다.
- 주문 가격 조회( getTotalPrice() ): 주문 가격에 수량을 곱한 값을 반환한다.

### 주문 리포지토리 개발

- save() : 주문 정보를 em의 persist 메서드를 통해서 저장한다.

- findOne() : 주문 정보의 id를 기반으로 em의 find 메서드를 통해서 단건 조회한다.

 ### 주문 서비스 개발

주문 서비스는 주문 엔티티와 주문 상품 엔티티의 비즈니스 로직을 활용해서 주문, 주문 취소, 주문 내역 검색 기능을 제공한다.

- 주문( order() ): 주문하는 회원 식별자, 상품 식별자, 주문 수량 정보를 받아서 실제 주문 엔티티를 생성한후 저장한다.
- 주문 취소( cancelOrder() ): 주문 식별자를 받아서 주문 엔티티를 조회한 후 주문 엔티티에 주문 취소를요청한다.

JPA 장점: 데이터 변경하고 원래는 쿼리 일일이 날려야하는데 JPA가 변경내역을 감지 해서 변경내역에 따라 DB에 업데이트 쿼리 알아서 날려준다.

- 도메인 모델 패턴 : 엔티티가 비즈니스 로직을 가지고 서비스는 단순히 엔티티에 필요한 요청을 위임하는 역할을 해서 객체지향의 특성을 적극 활용하는 것
- 트랜잭션 스크립트 패턴 : 엔티티에는 비즈니스 로직이 거의 없고(getter, setter 정도만 존재) 서비스 계츠엥서 대부분의 비즈니스 로직을 처리하는 것

### 주문 기능 테스트

- 상품 주문 테스트 : Given - 테스트를 위한 상품과 회원을 만든다. when - 실제 상품을 주문한다. then - 주문가격이 올바른지, 주문 후 재고 수량이 정확히 줄었는지 검증(assertEquals(메시지, 기댓값, 실제값))

- 재고 수량 초과 테스트 : given - 테스트를 위한 회원과 상품을 만들고 주문수량을 설정한다. when-  재고 수량이 초과되도록 실제 상품을 주문해서 NotEnoughStockException 예외가 발생하게 한다. then- 여기까지 오면 에러 메시지를 띄운다.

- 주문 취소 테스트 : given - 주문한다. when - 해당 주문을 취소한다. then - 주문상태가 CANCEL로 바뀌었는지, 취소한 만큼 재고가 증가했는지 검증한다.
