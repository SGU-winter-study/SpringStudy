# 영속성 컨텍스트
JPA를 이해하는데 가장 중요한 용어다.
엔티티를 영구 저장하는 환경이라는 뜻이다.

## 영속성 컨텍스트의 이점
1. 1차 캐시
영속성 컨텍스트는 내부적으로 1차 캐시를 들고있다.

조회를하면 JPA는 영속성 컨텍스트에서 1차 캐시를 뒤진다. 1차 캐시에 있는 값이면 그 값을 그냥 조회해버린다. 

1차 캐시에 없으면 DB를 조회하고, 조회한 결과를 1차 캐시에 저장한다.
근데 트랜잭션 단위로 작동해서 한 서비스의 트랜잭션이 끝나면 같이 폐기되므로 성능상의 큰 발전은 없다.

2. 동일성 보장
트랜잭션 단위로 작동을하고 관리를 하기 때문에, 한 트랜잭션 안에서는 반복 읽기를 한 경우에는 같은 값을 반환한다.


3. 트랜잭션을 지원하는 쓰기 지연
트랜잭션을 커밋하기 전까지 SQL을 보내지않고 기다렸다가 커밋할 때, 쏜다.
쿼리들을 모았다가 보내는게 정말 어려운데, 쿼리들의 버퍼링을 모았다가 쏴준다.

4. 변경 감지
한 트랜잭션 내에서 같은 값을 호출하면 같은 값이 나오고, 어디선가 변경을 하면 commit 할 때, 업데이트를 해준다.
마치 자바 컬렉션에서 하는 것처럼 값만 바꿔줘도 디비에 반영된다.

그 동작방식은 다음과 같다.
commit하는 시점에 내부적으로 flush( )가 호출된다. 호출되면, 엔티티와 스냅샷을 비교한다. 

비교를 해서 변화가 있으면, 쓰기 지연 SQL 저장소에 업데이트 쿼리를 저장해놨다가. flush해서 디비에 변경내용을 반영한 다음에  commit을 한다.
#### 플러시
데이터배이스 트랜잭션이 커밋되면 플러시가 발생한다.
발생하면, 변경을 감지하고 수정된 엔티티 쓰기 지연 sql저장소에 등록을 한다.
그 다음 한꺼번에 디비로 쫙 보내준다.
영속성 컨텍스트를 비우지않기 때문에, 플러시를 해줬다고 1차 캐시를 버리거나 하는 일은 일어나지않는다.

 영속성 컨텍스트의 변경 내용을 디비에 동기화 해준다. 트랜잭션이라는 작업 단위 안에서 기능을 하며, 커밋 직전에 동기화해준다.

#### 영속성 컨텍스트를 플러시하는 방법
1. em.flush()
강제로 부르면 플러쉬 과정이 그 즉시에 일어난다.

2. 트랜잭션 커밋

3. JPQL 쿼리 실행
JPQL 쿼리 실행시 플로시가 자동으로 호출되는 이유는 다음과 같다.
트랜잭션 안에서 persist로 넣은 애까지 조회해야하는 경우가 있다. 이런 경우에 에러가 날 수 있어서, 기본적으로 JPQL 쿼리를 날리면 무조건 플러시를 하도록 설정되어있다.

4. 지연 로딩

## 준영속 상태
1차 캐시에 올라간 상태를 영속상태라고 하는데, 영속 상태의 엔티티가 영속성 컨텍스트에서 분리되는 것을 준영속 상태라고 한다. 
준영속 상태면 더티 체크 등의 영속성 컨텍스트가 제공하는 기능을 사용하지 못한다.

#### 준영속 상태로 만드는 법
1. em.detach(entity) - 특정 엔티티만 떼어낸다.
2. em.clear() - 영속성 컨텍스트를 완전히 초기화 해버림
3. em.close() - 영속성 컨텍스트를 종료
