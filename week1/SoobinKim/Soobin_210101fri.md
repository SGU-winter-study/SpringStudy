## SOLID
* SRP(Single Respoinsibility Principle, 단일 책임 원칙)
하나의 클래스는 하나의 책임만을 가져야 한다.
즉, 변경사항이 생겼을 때 파급 효과가 적어야 한다.

* OCP(Open-Closed principle, 개방-폐쇄 원칙) ★
소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
만약 클라이언트 코드에서 구현 클래스를 직접 선택하는 경우, 해당 구현 클래스를 변경하고 싶은 경우 어쩔 수 없이 그 코드 자체를 변경해야만 한다. => OCP 가 지켜지고 있지 않음! 이 문제를 해결하기 위해서, 객체를 생성하고 연관관계를 맺어주는 별도의 조립/설정자가 필요하다. (이 '조립/설정자' 역할을 해 주는 것이 Spring 프레임워크이다.)

* LSP(Liskov Substitution Principle, 리스코프 치환 원칙)
특정한 인터페이스를 구현하는 하위 클래스는 인터페이스 규약을 지켜야 한다. 즉, 프로그램의 정확성을 깨트리지 않도록 기능적인 보장이 필요하다. 컴파일에 성공하여 프로그램이 돌아가더라도 그 동작 결과가 규약과 다르다면 LSP에 위배되는 것이다.

* ISP(Interface Segregation Principle, 인터페이스 분리 원칙)
기능별로 인터페이스를 명확하게 분리하여 인터페이스를 명확히 하고 인터페이스의 대체 가능성을 높인다. 즉, 하나의 인터페이스가 모든 역할을 수행하고 있도록 하지 않는다. 인터페이스를 쪼개는 것이 필요하다.

* DIP(Dependency Inversion Principle, 의존관계 역전 원칙) ★
구현 클래스에 의존하지 않고 인터페이스에 의존해야 한다. "추상화에 의존해야지, 구체화에 의존해서는 안 된다"는 원칙. 즉, 역할 그 자체에 의존해야 한다. 구현체 그 자체에 의존하게 되는 순간 변경이 어려워진다.
※ '의존한다'는 것은 그 코드를 '알고 있다'는 것과 동일하다.

객체 지향의 핵심은 **다형성** 이지만, 다형성 하나만으로는 OCP, DIP를 완전히 지키는 것이 불가능하다. (클라이언트 코드의 변경 없이 구현 객체를 변경하는 것이 불가능하다.) 무언가 더 필요하게 된다. 이러한 배경에서 등장한 것이 Spring이다.

## 객체 지향과 스프링
스프링은 DI와 DI컨테이너를 통해 다형성과 동시에 OCP, DIP가 가능하도록 지원한다. 즉 클라이언트 코드의 변경 없이 기능을 확장하는 것이 가능해진다.













