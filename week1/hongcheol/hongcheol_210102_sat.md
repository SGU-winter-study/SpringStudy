# 관심사의 분리
클라이언트 서비스가 혼자 너무 많은 일을 하고있어서 하나에만 집중할 수 있도록 만들어주는 것이다.
실제 실행되는 객체들은 본인의 역할만 하도록 설계해야한다.
코드를 구성영역과 사용영역으로 나눈다고 생각하면 이해가 쉽다. 권한을 줄이면서 책임을 명확하게 해주는 것이다.

이때 사용하는 것이 AppConfig이다.
### AppConfig
애플리케이션의 전체 동작 방식을 구성하는 클래스로 구현 객체를 생성하고 연결해주는 역할을 하는 클래스다.

기존에는 구현체에서 했던 실제 동작에 필요한 구현 객체를 생성하고 주입하는 역할을 한다.
기존에 객체를 생성하던 구현체에서는 생성자를 통해서 구현체가 뭐가 들어갈지 선택하는 생성자 주입 방식을 사용한다.

인터페이스에만 의존하고 구체적인 class에대해서 전혀 모르게 만들면서 철저하게 DIP를 지킬 수 있다는 장점이 있다.
의존관계에대한 고민은 외부(AppConfig)에 맡기고 어떤 클래스가 들어올지와는 관계없이 해당 클래스가 수행해야하는 역할에대한 로직만 실행하도록 설계한다. 즉, 실행에만 집중한다는 뜻이다.

한마디로, 관심사의 분리는 기능에따라 역할을 분리하는 것이다. 기능을 수행하는 역할에서 의존관계까지 결정하는 것이 아니라 외부에서 정해져서 전달된 것을 이용해 본인의 책임만을 다하는 것이다.
의존관계를 외부에서 주입해주는 것과 같고해서 의존관계 주입(DI)라고 한다.
 이 말은 코드에서 import 할 때, appconfig class를 제외하고, interface만 import하는 것을 의미하는 것 같다.
아래와 같이 의존관계를 주입받을 구현체에서 AppConfig 인스턴스를 만
들어서 그 안에 있는 메서드를 사용하는 방식으로 사용한다.
AppConfig appConfing = new AppConfing();

구체 클래스를 뭐로할지에대한 고민을 하는 역할을 외부로 넘기면서 구현체에서는 실행에대한 관심과 책임만을 지도록 한다. 이는 자연스럽게 단일 책임 원칙도 지키게해준다.

## 일단 분리를 한 후에 리팩터링을 통해서 중복을 제거하고 역할에 따른 구현이 잘 보이도록한다. 
리팩토링을 할 때는 리턴 타입은 interface 타입으로 해줘야지 중복을 피함과 동시에 메서드 명을 가져오는 순간 역할이 들어나게해준다.
각 메서드마다 역할이 명확해지면, 추후에 특정 역할에대한 변화가 생겼을 때, 그 역할에 해당하는 곳만 수정하면 된다.
최소한의 부분만 수정하면 되면서, 외부에서 변화가 발생했을 때, 빠르게 대응할 수 있고, 수정할 곳이 적기 때문에, 실수를 할 곳도 적어지므로 개발 효율성도 높아지게 되는 것이다.

관심사의 분리를 통해서 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리할 수 있어져 객체지향을 정말 잘 활용할 수 있게되는 것 같다.

# IoC,DI, 그리고 컨테이너
제어의 역전
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에 의해서 관리하는 것을 의미한다.

토비의 스프링 p.88 참고

의존관계는 정적인 의존관계와 동적인 의존관계가 있다.
정적인 의존관계는 클래스 의존 관계이고, 동적인 의존관계는 실행 시점에서 결정되는 객체(인스턴스) 의존관계를 의미한다.

정적인 의존관계는 intelliJ 기준으로 프로젝트 패키지에서 우클릭하고 show diagram 들어간 다음에 그 화면에서 우클릭을 해서 show dependencies를 하면 화살표로 의존관계가 표현된 다이어그램을 얻어서 의존관계를 확인할 수 있다. 이를 통해서 정적인 의존관계를 실행하지않고도 알 수 있다.

실행시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라한다. 즉 의존관계 주입은 동적인 의존관계를 결정해주는 것이다.

의존관계 주입을 사용하면, 클라이언트 코드의 수정없이 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
또한 정적인 클래스 의존관계를 변경하지않고도(애플리케이션 코드를 손대지않고) 동적인 의존관계를 쉽게 변경할 수 있게되는 것이다.

# 컨테이너
AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC 컨테이너(제어의 역전이 일어나기 때문), DI 컨테이너(의존관계 주입을 잘해주는 애라서)라고 한다. 
최근에는 IoC보다는 DI 컨테이너라고한다.

스프링이 DI 컨테이너 역할을 한다.

# 스프링 사용 방법
스프링을 사용하려면 ApplicationContext를 이용해서 시작한다. 이는 스프링 컨테이너를 사용하겠다는 의미다.
applicationContext는 등록된 bean을 관리해주는데, 그 방식은 AnnotationConfigApplicationContext를 사용한다.
이때 파라미터로 AppConfig.class와 같은 구성영역 클래스를 넣어주면 된다.

등록이 method 이름으로 등록되기 때문에 applicationContext에서 .getBean(“메소드 이름”, 메소드 클래스)를 통해서 필요한 것을 찾아다가 쓰면 된다.

AppConfig를 사용해서 했던 DI를 이제 applicationContext를 이용해서 해준다. 스프링 빈 = 스프링 컨테이너에 등록된 객체.
단축키
Command + E -> 과거의 히스토리가 다 보임
Command + E 하고 Enter 치면 직전에 봤던 창을 보여준다.
Command + option + M
