# 요구사항과 설계
요구사항을 보고 역할과 구현을 구분해야한다.
인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계한다.

설계 할 때, 클래스 다이그램과 객체 다이어그램을 그려서 진행하는데, 클래스 다이어그램은 정적이고 객체 다이어그램은 동적이다.
서비스 인터페이스의 구현체가 리파지토리 인터페이스를 바라본다.
서버가 뜨면 실제로 참조하는 주소값에는 서비스의 구현체와 같이 생각하면 된다.

실제 코딩을 할 때, 클래스와 인터페이스는 같은 패키지에 두지않는 것이 좋다.

설계상의 문제점을 파악해야한다.
의존성에 관한 부분을 주의깊게 보는 것이 중요하다.

역할과 구현을 분리해서 자유롭게 구현 객체를 조립할 수 있도록 설계해야한다. 
그 결과로 역할들의 협력관계를 그대로 유지할 수 있다.

단일책임의 원칙을 잘 지키면서 역할을 잘 분리해야한다.

실제 코딩을 하면서 실수로 MemberService부분을 구현 안하고 테스트를 돌려봤는데, 테스트가 실패했다. 그리고 MemberService부분을 구현하고 다시 테스트를 돌려보니 바로 통과하는 것을 확인할 수 있었다.

이런 이유 때문에 테스트는 필수이고, 실패하는 테스트도 꼭 만들어봐야한다. 나와야하는 값과 다른 값을 기대한다는 테스트를 돌렸는데 이게 통과해버리면 문제가 있는 것이기 때문이다.
# 요구사항의 변경

요구사항에서 변경이 생기면 변경된 부분에 관련된 역할을 수정해주면된다.

클라이언트 코드인 구현체 코드를 고쳐야하는 경우가 있다.
	역할과 구현을 충실하게 분리하고, 다형성도 활용하고 인터페이스와 구현 객체를 분리해서 구현해도 고쳐야하는 경우가 있다.

그 이유는 무엇일까??

DIP나 OCP와 같은 객체지향 설계 원칙을 지킨 것 처럼 보이지만 사실은 그렇지않기 때문이다.

클래스 의존관계를 분석해보면 클라이언트가 인터페이스에만 의존하는 것이 아니라 인터페이스의 구현 클래스에까지 의존을하고 있기 때문이다. 
이러한 이유로 기능을 확장해서 변경하는 경우에, 클라이언트에 영향을 주게되고, 이는 OCP를 위반한 것이다.

해결책 : 인터페이스에만 의존하도록 설계와 코드를 변경한다. -> 그렇게되면 구현체가 없어진다. 
그런데 구현체가 없는데 어떻게 코드를 실행할 수 있을까?? -> 누군가가 객체를 대신 생성해서 주입해주면된다. = DI


# 단축키
fn + f2 => 오류난 곳으로 바로 이동
