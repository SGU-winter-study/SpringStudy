# DI와bean

optional 
JAVA에서 null을 리턴해줄 때 있는 그대로 null을 리턴해주는 것이 아니라 Optional을 이용해서 감싸서 전달해줄 때 사용.
	Optional.ofNullable()을 해서 반환을 하면 null이 리턴된 경우에도 클라이언트쪽에서 무언갈 할 수 있게 해준다.
	NullPointerException에대한 처리인 것 같기도함. - 추후에 조사해서 업데이트 할 예정

Optional<Member> result = memberRepository.findByName(member.getName());
result.ifPresent(m->{
    throw new IllegalStateException(“이미 존재하는 회원입니다.”);
});와 같은 방식으로 코딩이 가능함. null인 경우에도 뭔가 할 수 있게함.


탐색할 때, 람다를 사용하기도 함
	람다에 관련한 내용
		뭔가 파이썬에서 사용한거랑 비슷한 개념일듯
실무쪽에서는 동기화 처리를 위해서 ConcurrentHashMap을 이용.

실무에서는 동시성을 잘 관리해줘야함.

실무에서는 리스트도 많이 씀

작성한 코드를 검증할 때, 테스트 케이스를 돌려서 검증
코드를 코드로 검증하는 것.

main 메서드를 통한 검증이나 컨트롤러를 통해서 검증하는 것은 실행이 오래걸리고 반복 실행이 어렵고 여러개의 테스트를 한 번에 실행하기 어렵다는 한계가 있다.
이를 극복하기 위해서 테스트를 사용

test 순서는 독립적으로 진행된다.
test 순서를 의존적으로 진행하면 안된다.
그래서 테스트를 할 때 필요한게 하나의 테스트 끝날 때마다 저장소나 공용 데이터를 정리해줘야함. -> @AfterEach를 사용
테스트를 작성할 때는 한글로 적어도 가능

given - when - then으로 잘라서 생각

try-catch 말고도 예외를 처리하는 방법
assertThrows();

테스트코드에서 사용하는 인스턴스와 실제 코드에서 생성되는 인스턴스가 다름(static 이 아닌 경우) 같은 것으로 테스트 해야하기 때문에, 생성자를 이용

DI - 직접 new 하지않고 외부에서 넣어주는 것을 Dependency Injection 이라고 함.

지금은 코드를 작성하고 테스트를 만들어보지만 TDD(테스트 주도개발)을 이용해서 먼저 테스트 코드를 작성하고 보수
TDD에 대한 내용은 추후에 업데이트할 예정
Assertions
종류가 다양하지만 개인적으로
import org.assertj.core.api.Assertions;
에서 가져오는게 코드의 가독성이 좋은 것 같다.


서비스 클래스쪽은 비즈니스 의존적으로 네이밍함. 서비스는 비즈니스를 처리하는거니까


스프링 빈과 의존관계
@Controller 어노테이션이 있으면 스프링이 뜰 때, 컨테이너에 컨트롤러를 생성해서 관리를 한다. 
스프링 컨테이너에 등록을 하고 사용하면 됨
Autowired 어노테이션을 생성자에 달아서 생성자를 호출하면 스프링 컨테이너에 있는거랑 연결을 해줌
스프링 bean으로 등록을 해야지 DI 가 가능하다. 스프링이 관리하는 애임을 알아야햠. 그냥 순수한 자바코드면 모름. 그래서 @Service를 달아줘야함.
컨트롤러
서비스
레포지토리
구조로 하는게 정형화된 패턴

컨트롤러랑 서비스 연결하는게 Autowired
이처럼 서비스 입장에서 뭔가가 밖으로부터 주입이 되는 걸 DI라고함.

 스프링 빈 등록하는 방법
제어권을 가지고 직접 만들과 관계를 부여하는 오브젝트 -> 빈
일반적으로 컴포넌트 스캔을 많이 사용한다.
어노테이션을 이용해서 해주는게 컴포넌트 스캔해서 자동으로 의존관계를 설정해주는방법

자바 코드로 직접 스프링 빈을 등록하는 것
	이거는 직접 작성해서 관리할 것을 알려줌
@Configuration을 달아줘서 사용
@Bean을 달아서 작성해놓으면 스프링이 올라올 때 @Bean 붙은 애들을 올려주고서 Autowired와 비슷하게 묶어준다.

Controller는 스프링이 어차피 알아서 관리를 해주는거라서 컴포넌트 스캔이랑 동일하게 사용하면 된다.
이거 실제로 하라그러면 구조 생각하고 하는게 어려울 것 같다.

	
왠만한거는 다 스프링 빈으로 등록을 해서 써야함. 등록을 할 때, 싱글톤으로 등록하게한다.(하나의 클래스에대해서 하나의 인스턴스만을 사용해야한다.)

main 메소드가 있는 곳에서 package로 등록되어있는 패키지를 포함한 그 하위항목들에 중에서 컴포넌트가 달려있는거를 자동으로 찾아서 의존관계를 주입해줌.

DI는 3가지 방법(그 위치에 Autowired 하면 됨)
생성자
필드 주입//중간에 바꿀 방법이 없어서 별로 안좋다.
setter 주입//중간에 바꿀 일이 없는 요소를 public으로 노출을 해야해서 문제가 발생할 수 있다. 아무나 접근을 할 수 있어서 위험하다.

그래서 제일 권장되는 스타일은 생성자를 통해서 주입을 하면 스프링 컨테이너에 올라가면서 조립되는 시점에 들어오고 그 뒤부터는 변경을 못하도록 막아버릴 수 있다. (의존 관계가 실행 중에 동적으로 변하는 경우가 없다 -> 이런 일 있으면 서버를 내리고 config수정해서 다시 올려주는 것을 선택한다.)
상황에 따라서 구현 클래스를 변경해야하면 설정을 통해서 스프링 빈으로 등록한다. -> bean을 이용해서 외부의 반응에대해서 민감하게 반응하지않고,특정부분만 수정하면 정상 작동하도록 할 수 있다.

단축키(나중에 단축키만 따로 묶어서 정리할 예정)
fn + shift + f6 -> rename

command option v

command shift T -> 테스트 껍데기 자동으로

control t -> extract method 하면 메소드로 추출할 수 있음.
