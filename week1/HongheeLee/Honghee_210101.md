## 스프링 핵심 원리 이해1 - 예제 만들기

### 프로젝트 생성

프로젝트 생성은 스프링 입문 강의에서의 과정과 유사하다. Gradle, Java, 11 선택.

처음에는 순수 자바 코드로만 구현하기 위해 Dependencies를 아무 것도 선택하지 않는다는 것만 다르고.

### 비즈니스 요구사항과 설계

회원, 주문, 할인 정책을 구현해야한다. 그런데 회원 데이터 저장방식, 할인 정책과 같이 아직 결정되지 않은 부분들이 있어도 개발을 일단 진행해야 하는 경우가 많다. 이 때 필요한 것이 객체 지향 설계, 역할과 구현의 분리. 인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계한다. 

### 회원 도메인 설계

요구사항 : 회원을 가입하고 조회할 수 있다. 회원은 일반과 VIP 두 가지 등급이 있다. 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다(미확정)

회원 도메인의 각 역할을 인터페이스로 설계한다. 특히 회원 저장소의 역할을 인터페이스로 설계하는데 메모리 회원 저장소로 일단은 구현한다. 데이터 저장 방식이 결정되면 추가로 구현해서 갈아끼우기만 하면 되니까.  

객체 간의 관계에서는 클라이언트는 회원 서비스 객체를 바라보고 회원 서비스 객체는 메모리 회원 저장소를 바라보도록 설계. 

도메인 협력관계: 기획자도 함께 볼 수 있는

클래스 다이어그램: 구체화해서 인터페이스와 클래스들 보여줌, 정적임.

객체 다이어그램: 서버가 뜰 때 동적으로 결정된다. 클라이언트가 실제로 사용하는 걸 보여준다

### 회원 도메인 구현

Grade는 enum으로 회원 클래스는 id, name, grade를 필드로 가지고 각 필드값에는 getter, setter 메소드로 접근한다. 저장소는 우선 인터페이스로 설계하고 방식이 결정되지 않았기 때문에 메모리리포지토리로 구현한다. 

이때 구현 클래스의 필드로 Map 자료형을 활용하는데 이는 파이썬의 dict 자료형과 유사하다. key와 value를 한쌍으로 가지며 리스트나 배열처럼 순차적으로 해당 요소의 값을 구하지 않고 key를 통해 value를 구한다. Map은 인터페이스여서 이를 구현한 Map 자료형에는 여러 가지가 있는데 대표적인 것이 HashMap이다. get, put, containsKey, remove, size 메소드가 있다.

```
HashMap<String, String> map = new HashMap<String, String>(); 

map.put("people", "사람");	// HashMap에 key와 value를 입력한다. 
System.out.println(map.get("people"));// 주어진 key값에 해당하는 value값을 얻는다.
System.out.println(map.containsKey("people")); // 맵에 해당 키가 있는지 조사해서 그 결과를 리턴한다.
System.out.println(map.remove("people")); // 주어진 key값에 해당하는 아이템(key, value)를 삭제한 후 그 value값을 리턴한다.
System.out.println(map.size()); // Map의 개수를 리턴한다.
```

동시성 이슈가 발생할 수 있어서 실제로는 HashMap이 아니라 ConcurrentHashMap을 사용해야 한다. 

### 회원 도메인 실행과 테스트

메인 메소드에서 찍어보면서 테스트할 수도 있지만 junit 활용해서 테스트할 수 있다.

테스트할 때는 given, when, then 방식으로 코드 작성. 이런이런게 주어졌을 때, 이렇게 했을 때, 이렇게 된다.

then 단계에서 검증하는 코드는 아래와 같고 여기서 Assertions.assertThat()은 junit이 아니라 assertj를 import해야 사용할 수 있다.

```java
Assertions.assertThat(member).isEqualTo(findMember);
```

회원 도메인 설계의 문제점? OCP? DIP? 인터페이스뿐만 아니라 구현까지 의존하게 됨. 할당하는 부분이 구현체를 의존하니까. 

### 주문과 할인 도메인 설계, 개발

주문 도메인 협력, 역할, 책임

1. 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
2. 회원 조회: 할인을 위해서는 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원을 조회
   한다.
3. 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임한다.
4. 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다.

역할과 구현을 분리! 역할 먼저 만들고, 구현은 나중에 만든다. 주문 서비스, 회원 저장소, 할인 정책 인터페이스 먼저 설계하고 구현체는 나중에 만들어서 갈아끼울 수 있게 만든다. 역할들의 협력관계를 그대로 재사용할 수 있다.

인터페이스에 대한 구현체가 하나만 존재하면 클래스명은 인터페이스명+Impl로 하는게 관례.

### 주문과 할인 도메인 실행, 테스트

여기서 할인 정책은 order에서 다루지 않고 discount에 완전히 맡긴다. 그래서 할인 정책의 변경이 있을 때는 order는 수정할 필요 없이 discount만 수정하면 된다. 책임 분리!

테스트는 역시 메인 메소드로도 가능하고 junit을 활용해서도 가능하다. 테스트는 통합테스트보다는 단일 테스트를 잘 구현하는게 중요하다. 스프링 띄우고 다 하려면 오래 걸리니까. 단일 테스트란 스프링 컨테이너의 도움없이 순수한 자바 코드로 구현한 것을 의미한다. 

---

## 스프링의 핵심 원리 이해2 - 객체 지향 원리 적용

기획자가 나타나서 새로운 할인 정책을 요구한다면?!? 

여러 문제 발생. 해결하기 위한 여러 방법 도입. 스프링과 가깝게 다가가게 된다. 그리고 스프링으로 전환해보자.

### 새로운 할인 정책 개발

정액할인 -> 정률할인 변경. 앞에서 객체지향 설계 원칙 준수했으니 바로 갈아끼울 수 있을까?

테스트할 때 성공테스트도 중요하지만 실패 테스트도 꼭 만들어 봐야 한다.  

Assertions는 import static 해서 간단하게 사용하는게 좋다.

### 새로운 할인 정책 적용과 문제점

할인 정책을 변경하려면 클라이언트인 OrderServiceImpl의 코드를 고쳐야 한다. 

역할과 구현을 분리하고 다형성을 활용해 인터페이스와 구현 객체를 분리했지만 OCP, DIP 원칙을 준수 X. 

클라이언트인 OrderServiceImpl은 인터페이스뿐만 아니라 구현 클래스에도 의존하고 있기 때문에 DIP 위반.  그래서 정책을 변경하는 순간 의존관계가 있기 때문에 클라이언트의 코드를 변경해야 하고 그러면 OCP(변경하지 않고 확장할 수 있다) 위반.  

해결? 추상(인터페이스)에만 의존하도록 변경해야 한다.  단순히 구현 클래스 삭제?  -> NullPointerException  발생(Null에다가 점찍으면 발생). 

누군가 클라이언트에 구현 객체를 대신 생성하고 주입해주어야 한다!

### 관심사의 분리

애플리케이션의 전체 동작 방식을 구성(config)하기 위해 **구현 객체를 생성**하고 **연결**하는 책임을 가지는 별도의 설정 클래스 생성.

AppConfig는 애플리케이션이 실제 동작에 필요한 **구현 객체를 생성** 한다. 생성한 객체 인스턴스의 참조를 **생성자를 통해서 주입**(연결)한다

이를 통해서 클라이언트는 구현 클래스(구체)에 의존하지 않고 인터페이스(추상)에만 의존한다.  어떤 구현 객체를 주입할지는 오직 외부에서 결정된다. 의존 관계 고민 없이 실행에만 집중한다.

객체를 생성하고 연결하는 역할과 실행하는 역할이 명확하게 분리된다. 

클라이언트 입장에서는 의존관계를 외부에서 주입해주는 것 같다고 해서 DI(Dependency Injection), 의존관계 주입이라고 한다. 

### AppConfig 리팩터링

역할이 무엇이 있고 구현을 어떻게 하는지 한눈에 보이는 것이 중요한데, 현재 AppConfig를 보면 중복이 있고 역할에 따른 구현이 잘 안보인다.  

리팩터링하면 역할과 구현 클래스가 한눈에 들어오고 애플리케이션  전체 구성이 어떻게 되어있는지 빠르게 파악할 수 있다. 

### 새로운 구조와 할인 정책 적용

FixDiscountPolicy -> RateDiscountPolicy 변경. AppConfig만 변경하면 됨.  AppConfig의 등장으로 애플리케이션이 크게 사용 영역과, 객체를 생성하고 구성하는 영역으로 분리되었기 때문에.

사용 영역의 코드는 변경할 필요 없고 구성 영역의 코드만 변경하면 된다.  DIP와 OCP 준수하게 됨.

### 좋은 객체 지향 설계의 5가지 원칙 적용

- SRP 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.

  기존 클라이언트 객체는 직접 구현 객체를 생성하고 연결하고 실행하는 다양한 책임을 가지고 있었는데 수정 후에는 클라이언트 객체가 실행 책임을 담당하고 AppConfig가 생성 연결하는 책임을 담당하도록 했다.

- DIP 의존관계 역전 원칙 : 추상화에 의존해야지 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나이다. 

  기존 클라이언트는 인터페이스에도 의존하고 구현 클래스에도 의존하고 있었다. AppConfig가 클라이언트 대신 객체 인스턴스를 생성해서 클라이언트에 의존관계를 주입해서 DIP 문제를 해결했다.

- OCP 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다.

  다형성 사용하고 클라이언트가 DIP를 지킨다. 애플리케이션은 사용 영역과 구성 영역으로 나눔. 

  사용 영역의 변경은 닫혀있다. 변경이 닫혀있다는 것은 코드를 수정할 필요가 없다는 뜻. 

### IoC, DI, 컨테이너

- 제어의 역전 IoC

  프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라고 한다. 여기서는 AppConfig가 프로그램 제어 흐름을 가지고 있다. 다른 코드들만 봐서는 어떤게 호출이 될지 모른다. 

  프레임워크 vs 라이브러리 : 프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 프레임워크,  내가 작성한 코드가 제어의 흐름을 담당하면 라이브러리.

- 의존관계 주입

  인터페이스에만 의존해서 실제 어떤 구현 객체가 사용될지 모른다.

  의존관계는 **정적인 클래스 의존관계**와, **실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계**를 분리해서 생각해야 함.  상속이든 인터페이스 구현이든 화살표 방향으로 의존한다. 

  실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 **의존관계 주입** 이라고 한다.  이를 활용하면 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존 관계를 쉽게 변경할 수 있다.  ex) 정액->정률, 메모리->DB

- IoC 컨테이너, DI 컨테이너

  AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC 컨테이너(제어의 역전에 초점), **DI 컨테이너**(의존관계 주입에 초점).

### 스프링으로 전환

순수한 자바코드로 DI를 구현했는데 이를 스프링으로 바꿔본다.

ApplicationContext를 스프링 컨테이너라 한다. 이제부터는 스프링 컨테이너를 통해 DI를 한다.  

스프링 컨테이너는 @Configuration이 붙은 'AppConfig'를 설정 정보로 사용한다. 여기서 @Bean이라 적힌 메소드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.

스프링 빈은 @Bean이 붙은 메소드 명을 스프링 빈의 이름으로 사용한다. 

필요한 객체를 스프링 컨테이너를 통해 찾아야 한다. applicationContext.getBean("스프링빈 이름", 타입)를 통해 가져올 수 있다.

장점? 스프링 컨테이너가 관리해주면서 얻는 이점 아주 많다. 앞으로 알아볼 것.

---

### 단축키

세미콜론 포함한 코드 자동완성 : ctrl + shift + enter 

생성자 / getter, setter 메소드 생성 : Alt + insert

메인 메소드 : psvm

프린트 : sout

프린트하는데 위에서 변수 선택 : soutv

변수 자동 생성 후 할당 : ctrl + Alt + v

오류 난 곳으로 이동 : F2

자동완성(import 필요할 때 or 구현체에서 메소드 오버라이딩, 생성자 생성) : Alt+ enter (애매하면 다 이거)

테스트 만들기 : Ctrl + shift + t

과거 히스토리 : Ctrl + e

메소드 추출 : Ctrl + Alt + m
